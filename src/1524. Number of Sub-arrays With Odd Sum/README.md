# [M] 1524. Number of Sub-arrays With Odd Sum

## 題目

- [LeetCode 連結](https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum/description)
- **主題**：Array、Prefix Sum、DP
- **難度**：Medium (Rating: 1610)
- **Daily**：2025-02-25

## 題目描述

給定一個整數陣列 `arr`，請返回 **總和為奇數** 的子陣列數量。

由於答案可能會非常大，因此請 **對 10⁹ + 7 取餘數** 後返回結果。

---

### 範例 1

```plain
輸入: arr = [1,3,5]
輸出: 4
解釋:
所有的子陣列如下：
[[1], [1,3], [1,3,5], [3], [3,5], [5]]

所有子陣列的總和分別為：
[1, 4, 9, 3, 8, 5]

其中奇數總和的子陣列為：
[1, 9, 3, 5]，所以答案是 4。
```

### 範例 2

```plain
輸入: arr = [2,4,6]
輸出: 0
解釋:
所有的子陣列如下：
[[2], [2,4], [2,4,6], [4], [4,6], [6]]

所有子陣列的總和分別為：
[2, 6, 12, 4, 10, 6]

所有子陣列的總和均為偶數，因此答案是 0。
```

### 範例 3

```plain
輸入: arr = [1,2,3,4,5,6,7]
輸出: 16
```

### 限制條件

- `1 <= arr.length <= 10⁵`
- `1 <= arr[i] <= 100`

---

## 解題思路

看題意像是 DP，但目前還不太熟所以直接參考官方教學的說明來學習。

- 規律：
  - 當前子陣列總和為奇數，加入偶數，新的結果會是奇數
  - 當前子陣列總和為偶數，加入奇數，新的結果會是奇數
- 目標只是要求每個子陣列的加總是否為奇數，所以其實 `arr` 中的值是多少不重要，我們只需要關心每個數是奇數或偶數，並依照當前索引位置來計數就可以，因此最一開始可以將 `arr` 依照奇偶性轉成 `0` 或 `1`
- 使用兩個 DP 陣列來從前到後記錄每個以當前索引值結尾的子陣列總和為奇數 `dpOdd` 或偶數 `dpEvent` 的個數

最後一步有點難理解，實際用 `1, 2, 3, 4, 5` 列舉為例：

- 以 1 結尾的子陣列有 `[1]`
  - `dpOdd[0]` 為 1
  - `dpEven[0]` 為 0
- 以 2 結尾的子陣列有 `[1, 2]`、`[2]`
  - 因為 2 為偶數
  - 要與奇數搭配才會是奇數，所以 `dpOdd[1]` 為 `dpOdd[0] = 1`
  - 與偶數搭配會是偶數，加上自己是偶數，所以 `dpEven[1]` 為 `dpEven[0] + 1 = 1`
- 以 3 結尾的子陣列有 `[1, 2, 3]`、`[2, 3]`、`[3]`
  - 因為 3 為奇數
  - 要與偶數搭配才會是奇數，加上自己是奇數，所以 `dpOdd[2]` 為 `dpEven[1] + 1 = 2`
  - 與奇數搭配會是偶數，所以 `dpEven[2]` 為 `dpOdd[1] = 1`
- 以 4 結尾的子陣列有 `[1, 2, 3, 4]`、`[2, 3, 4]`、`[3, 4]`、`[4]`
  - 因為 4 為偶數
  - 要與奇數搭配才會是奇數，所以 `dpOdd[3]` 為 `dpOdd[2] = 2`
  - 與偶數搭配會是偶數，加上自己是偶數，所以 `dpEven[3]` 為 `dpEven[2] + 1 = 2`
- 以 5 結尾的子陣列有 `[1, 2, 3, 4, 5]`、`[2, 3, 4, 5]`、`[3, 4, 5]`、`[4, 5]`、`[5]`
  - 因為 5 為奇數
  - 要與偶數搭配才會是奇數，加上自己是奇數，所以 `dpOdd[4]` 為 `dpEven[3] + 1 = 3`
  - 與奇數搭配會是偶數，所以 `dpEven[4]` 為 `dpOdd[3] = 2`

從上面的算是可以找到實作的規律：

```ts
function numOfSubarrays(arr: number[]): number {
  const MOD = 1e9 + 7;
  const n = arr.length;
  const tmpArray = [...arr];

  // 將所有數依照奇偶性轉成 1 或 0
  for (let i = 0; i < n; i++) {
    tmpArray[i] %= 2;
  }

  // dpEven[i] 代表以索引 i 結尾且當前總和為「偶數」的所有子陣列數目
  // dpOdd[i] 代表以索引 i 結尾且當前總和為「奇數」的所有子陣列數目
  const dpEven = Array.from({ length: n }, () => 0);
  const dpOdd = Array.from({ length: n }, () => 0);

  // 初始化第一個數的奇偶性
  if (tmpArray[0] === 1) {
    dpOdd[0] = 1;
  } else {
    dpEven[0] = 1;
  }

  // 從倒數第 2 個元素開始跑迴圈
  for (let i = 1; i < n; i++) {
    if (tmpArray[i] === 1) {
      // 當前數值為奇數時，需要找偶數累加、加上自己為新的奇數總和個數
      dpOdd[i] = (dpEven[i - 1] + 1) % MOD;
      // 總和要是偶數，需找前面為奇數累加數才會是
      dpEven[i] = dpOdd[i - 1];
    } else {
      dpEven[i] = (dpEven[i - 1] + 1) % MOD;
      dpOdd[i] = dpOdd[i - 1];
    }
  }

  // 加總所有奇數個數並作餘數處理
  return dpOdd.reduce((sum, count) => (sum + count) % MOD, 0);
}
```

複雜度分析，若 `arr` 長度為 `n`：

- 時間複雜度：兩個各跑 `n` 次的迴圈，因此為 `O(n)`
- 空間複雜度：三個長度 `n` 的陣列，因此為 `O(n)`
